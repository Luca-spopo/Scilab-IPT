/*

Author: Anirudh Katoch
katoch.anirudh(at)gmail.com

Expects input file "input.txt" in working directory.
Expects directory "output" in working directory.

Make sure you have your permissions set properly!

For usage and help, see input.txt

*/



#include<iostream>
#include<cstdio>
#include<cstring>
#include<sstream>
#include<limits>
#include<fstream>

using namespace std;

//Edit these to modify this program to work with other boxing/unboxing functions.
const char MAT2IL[] = "mat2il";
const char IL2MAT[] = "il2mat";
const char HEADER[] = "//Autogenerated wrapper function for: %s\n//Made by dev-tools/migrate to migrate from lists to hypermatrices.\n\n";


class Case
{
	public :
	string oldname;
	char args[100];
	int arg_length;
	Case()
	{
		arg_length = 0;
	}
	void addArg(int wrap)
	{
		args[arg_length++] = wrap;
	}
	void genCall(ostream &fout)
	{
		int i;
		fout<<oldname<<"(";
		for(i=0; i<arg_length-1; i++)
		{
			if(args[i]==1)
				fout<<MAT2IL<<"(";
			fout<<"varargin(";
			fout<<i+1;
			fout<<")";
			if(args[i]==1)
				fout<<")";
			fout<<", ";
		}
		if(args[i]==1)
		fout<<MAT2IL<<"(";
		fout<<"varargin(";
		fout<<i+1;
		fout<<")";
		if(args[i]==1)
			fout<<")";

		fout<<")";
	}
};

class FunctionFormat
{
	public :
	string newname;
	int return_length; //Number of values to be returned
	int case_length; //Number of cases
	char returns[100]; //Array of flags for if wrapper is needed around returned value
	Case cases[10]; //Array of cases, each case contains all info about the case.
	FunctionFormat()
	{
		return_length = 0;
		case_length = 0;
	}
	void prepUp()
	{
		newname = "Missingno"; //Default error-y name
		return_length = case_length = 0;
	}
	void addReturn(int wrap)
	{
		returns[return_length++] = wrap;
	}
	void addCase(Case the_case)
	{
		cases[case_length++] = the_case;
	}
	void resultAssignment(ostream &fout)
	{
		if(return_length>0)
		{
			fout<<"[ ";
			for(int i=0; i<return_length-1; i++)
			{
				fout<<"res"<<i+1<<", ";
			}
			fout<<"res"<<return_length<<" ] = ";
		}
	}
};


int getFunctionInput(istream &fin, FunctionFormat &function)
{
	function.prepUp();
	fin.ignore(numeric_limits<streamsize>::max(), ':');
	if(fin.eof())
		return 1; //Could not find a function
	fin>>function.newname;
	if(!fin)
		return 1; //There was nothing after colon
	while(fin)
	{
		int temp;
		fin>>temp;
		if(fin)
			function.addReturn(temp);
	}
	fin.clear();
	while(fin.peek()!=':' && !fin.eof())
	{
		char temp_string[1000];
		fin.getline(temp_string, 1000);
		stringstream case_string_stream(temp_string);
		Case temp_case;
		case_string_stream>>temp_case.oldname;
		while(case_string_stream)
		{		
			int temp_int;
			case_string_stream>>temp_int;
			if(case_string_stream)
				temp_case.addArg(temp_int);
		}
		
		function.addCase(temp_case);
	}
	return 0;
}

int makeFunctionFile(FunctionFormat funForm, string fout_path)
{
	ofstream fout((fout_path+funForm.newname+".sci").c_str());
	if(!fout)
		return 1; //Could not create file.
	char temp_str[1000];
	snprintf(temp_str, 1000, HEADER, funForm.newname.c_str());
	fout<<temp_str;

	char trivial;
	if(funForm.case_length > 1)
		trivial = 0;
	else
		trivial = 1;
	for(int i=0; trivial && i<funForm.return_length; i++)
		if(funForm.returns[i])
			trivial = 0;
//	for(int i=0; trivial && i<funForm.return_length; i++)
//		if(funForm.returns[i])
//			trivial = 0;
	for(int i=0; trivial && i<funForm.cases[0].arg_length; i++)
		if(funForm.cases[0].args[i])
			trivial = 0;

	if(trivial)
	{
		fout<<funForm.newname<<" = "<<funForm.cases[0].oldname;
		fout.close();
		return 0;
	}


	fout<<"function ";

	funForm.resultAssignment(fout);

	fout<<funForm.newname+"(varargin)\n\tselect length(varargin)";

	for(int i=0; i<funForm.case_length; i++)
	{
		fout<<"\n\t\tcase "<<funForm.cases[i].arg_length<<" then";
		fout<<"\n\t\t\t";
		funForm.resultAssignment(fout);
		funForm.cases[i].genCall(fout);
	}

	fout<<"\n\t\telse";
	fout<<"\n\t\t\terror(39)";
	fout<<"\n\tend";

	for(int i=0; i<funForm.return_length; i++)
		if(funForm.returns[i])
		{
			fout<<"\n\tres"<<i+1<<" = "<<IL2MAT<<"(res"<<i+1<<")";
		}

	fout<<"\nendfunction";

	fout.close();
	return 0;
}

void doEverything(ifstream &fin, string fout_path)
{
	FunctionFormat temp;
	while(fin)
		if(!getFunctionInput(fin, temp) && fin && !makeFunctionFile(temp, fout_path))
			cout<<"Generated function: "+temp.newname<<endl;
		else if (fin)
			cout<<"ERROR Could not generate function : "+temp.newname<<endl;
	fin.close();
}

int main()
{
	ifstream fin("input.txt");
	if(!fin.good())
	{
		cout<<"Error opening input.txt.";
		return 1;
	}
	while(!fin.eof())
	{
		fin.ignore(numeric_limits<streamsize>::max(), '/');
		if(fin.peek() == '/')
		{
			fin.ignore(1);
			break;
		}
	}
	if(fin.eof())
	{
		cout<<"Could not find //, or list is empty";
		return 1;
	}
	string fout_path = "output/";

	doEverything(fin, fout_path);

	return 0;
}
